// Copyright 2014, Catlike Coding, http://catlikecoding.com
using UnityEngine;
using System;

namespace CatlikeCoding.NumberFlow {

	/// <summary>
	/// Link between a NumberFlow diagram and materials.
	/// </summary>
	[Serializable]
	public sealed class DiagramMaterialLink {

		/// <summary>
		/// NumberFlow diagram.
		/// </summary>
		public Diagram diagram;

		/// <summary>
		/// Materials whose textures should be generated by the diagram.
		/// </summary>
		public Material[] materials;

		/// <summary>
		/// Settings for the generated textures.
		/// </summary>
		public DiagramTextureSettings textureSettings;

		/// <summary>
		/// Generated textures.
		/// </summary>
		[NonSerialized]
		public Texture2D[] textures;

		private static TextureFormat[] normalTextureFormats = {
#if UNITY_EDITOR || !(UNITY_IPHONE || UNITY_ANDROID || UNITY_BLACKBERRY || UNITY_WP8)
			TextureFormat.ARGB32,
#else
			TextureFormat.RGB24,
#endif
			TextureFormat.ARGB32,
			TextureFormat.RGB24,
			TextureFormat.ARGB32
		};

		/// <summary>
		/// Create the texture objects but do not fill them yet.
		/// </summary>
		public void AllocateTextures () {
			if (diagram == null) {
				textures = new Texture2D[0];
				return;
			}

			textures = new Texture2D[diagram.outputs.Length];
			for (int i = 0; i < textures.Length; i++) {
				TextureFormat format;
				bool linear = textureSettings.linear;
				switch (diagram.outputs[i].type) {
					case DiagramTextureType.ARGB: format = TextureFormat.ARGB32; break;
					case DiagramTextureType.RGB: format = TextureFormat.RGB24; break;
					case DiagramTextureType.Alpha: format = TextureFormat.Alpha8; break;
					default: // DiagramTextureType.NormalMap
						format = normalTextureFormats[(int)textureSettings.normalFormat];
						linear = true;
						break;
				}
				Texture2D t = new Texture2D(textureSettings.width, textureSettings.height, format, textureSettings.mipmap, linear);
				t.name = "Managed NumberFlow Diagram Texture";
				t.hideFlags = HideFlags.HideAndDontSave;
				t.filterMode = textureSettings.filterMode;
				t.wrapMode = textureSettings.wrapMode;
				t.anisoLevel = textureSettings.anisoLevel;
				textures[i] = t;
			}
		}

		/// <summary>
		/// Clean up textures.
		/// </summary>
		public void OnDestroy () {
			if (diagram == null || textures == null) {
				return;
			}
			for (int m = 0; m < materials.Length; m++) {
				Material material = materials[m];
				if (material != null) {
					for (int o = 0; o < diagram.outputs.Length; o++) {
						material.SetTexture(diagram.outputs[o].name, null);
					}
				}
			}
			for (int i = 0; i < textures.Length; i++) {
#if UNITY_EDITOR
				GameObject.DestroyImmediate(textures[i]);
#else
				GameObject.Destroy(textures[i]);
#endif
			}
			textures = null;
		}

		/// <summary>
		/// Initialize the buffers, fill and postprocess the textures.
		/// </summary>
		/// <param name="buffers">Pixel buffers.</param>
		public void Process (ref Color[][] buffers) {
			InitBuffers(ref buffers);
			diagram.Fill(buffers, textureSettings.width, textureSettings.height);
			diagram.PostProcess(buffers, textureSettings.width, textureSettings.height, textureSettings.normalFormat);
		}

		/// <summary>
		/// Initialize the buffers.
		/// </summary>
		/// <param name="buffers">Pixel buffers.</param>
		public void InitBuffers (ref Color[][] buffers) {
			if (buffers.Length < textures.Length) {
				Array.Resize(ref buffers, textures.Length);
			}
			int textureSize = textureSettings.width * textureSettings.height;
			for (int i = 0; i < textures.Length; i++) {
				if (buffers[i] == null) {
					buffers[i] = new Color[textureSize];
				}
				else if (buffers[i].Length < textureSize) {
					Array.Resize(ref buffers[i], textureSize);
				}
			}
		}

		/// <summary>
		/// Fill the specified rows of all textures. Return whether the last row was filled.
		/// </summary>
		/// <returns>Whether filling is done.</returns>
		/// <param name="buffers">Pixel buffers.</param>
		/// <param name="rowIndex">Row index to start from.</param>
		/// <param name="rowCount">How many rows to fill.</param>
		public bool FillRows (Color[][] buffers, ref int rowIndex, int rowCount) {
			rowIndex = diagram.FillRows(buffers, textureSettings.width, textureSettings.height, rowIndex, rowCount);
			return rowIndex >= textureSettings.height;
		}

		/// <summary>
		/// Post process the buffers for all textures.
		/// </summary>
		/// <param name="buffers">Pixel buffers.</param>
		public void PostProcess (Color[][] buffers) {
			diagram.PostProcess(buffers, textureSettings.width, textureSettings.height, textureSettings.normalFormat);
		}

		/// <summary>
		/// Apply the pixel buffers to all textures.
		/// </summary>
		/// <param name="buffers">Pixel buffers.</param>
		public void ApplyTextures (Color[][] buffers) {
			for (int i = 0; i < textures.Length; i++) {
				textures[i].SetPixels(buffers[i]);
				textures[i].Apply(true, true);
			}
		}

		/// <summary>
		/// Assign all textures to all materials.
		/// </summary>
		public void AssignTexturesToMaterials () {
			if (diagram == null || textures == null) {
				return;
			}

			for (int m = 0; m < materials.Length; m++) {
				Material material = materials[m];
				if (material != null) {
					for (int o = 0; o < diagram.outputs.Length; o++) {
						material.SetTexture(diagram.outputs[o].name, textures[o]);
					}
				}
			}
		}
	}
}